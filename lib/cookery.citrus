grammar CookeryGrammar
  rule file
    (space* (import space+)* activity space*)+ {
    (capture(:import) ? captures(:import).map(&:value).join("\n") +
      "\n": "") + captures(:activity).map {|a| a.value }.join("\n")
    }
  end

  rule import
    ('import' space+ /[\'\"]/ path /[\'\"]/ (space + 'as' space+ module_name)?)

    {
    n = Node.new(:import)
    n.set(:path, capture(:path).value)
    n.set(:module_name, capture(:module_name).value) \
        if capture(:module_name)
    add_node(n)

    capture(:module_name) ? "(import \"" + capture(:path).value + "\" " +
    capture(:module_name).value + ")" : "(import " + capture(:path).value + ")"
    }
  end

  rule path
    /[[:alnum:]\/_.-]+(\/[[:alnum:]\/_.-]+)*/
  end

  rule module_name
    /[[:alnum:]]/
  end

  rule activity
    ((var:(list_variable | variable) variable_separator)?
    space* action_group
    (space* subject_or_variable)?
    (space* condition_group)? END) <ActivityStatement>
  end

  rule variable
    /[[:upper:]][[:alnum:]]*/ {
      n = Node.new(:variable)
      n.set(:name, to_str)
      add_node(n)

      to_str
    }
  end

  rule list_variable
    (/[[:upper:]][[:alnum:]]*/ '[]') {
      n = Node.new(:list_variable)
      n.set(:name, to_str)
      add_node(n)

      to_str
    }
  end

  rule action_group
    (action (space+ action_arguments)?) {

    n = Node.new(:action)
    n.set(:name, capture(:action).value)
    add_node(n)

    if capture(:action_arguments)
      n.set(:arguments, capture(:action_arguments).value)
      capture(:action).value + " \"" +
      capture(:action_arguments).value + "\""
    else
      capture(:action).value
    end
    }
  end

  rule action
    /[[:lower:]_-]+/
  end

  rule action_arguments
    ~((space* /[[:upper:]]/) | (space* 'with') | END)
  end

  rule subject_or_variable
    ((subject_list | subject_group)
    (space+ AND space+ subject_or_variable)*) <SubjectOrVariable>
  end

  rule subject_list
    (/[[:upper:]][[:alnum:]]*/ '[]') {
      n = Node.new(:list_subject)
      n.set(:name, to_str)
      add_node(n)

      to_str
    }
  end

  rule subject_group
    (subject (space+ subject_arguments)?) {

    n = Node.new(:subject)
    n.set(:name, capture(:subject).value)
    n.set(:arguments, capture(:subject_arguments).value)
    add_node(n)

    if capture(:subject_arguments)
      n.set(:arguments, capture(:subject_arguments).value)
      "(" + capture(:subject).value + " " +
        capture(:subject_arguments).value + ")"
    else
      capture(:subject).value
    end
    }
  end

  rule subject
    /[[:upper:]][[:alnum:]]*/
  end

  rule subject_arguments
    ~((space* 'with') | (space* AND) | END) {
    "\"" + to_str + "\"" }
  end

  rule condition_group
    ('with' space+ condition (space+ condition_arguments)?) {

    n = Node.new(:condition)
    n.set(:name, capture(:condition).value)
    add_node(n)

    if capture(:condition_arguments)
      n.set(:arguments, capture(:condition_arguments).value)
      "(" + capture(:condition).value + " " +
        capture(:condition_arguments).value + ")"
    else
      capture(:condition).value
    end
    }
  end

  rule condition
    /[[:alnum:]]+/
  end

  rule condition_arguments
    ~END { "\"" + to_str + "\""}
  end

  rule comment /\#.*/ end
  rule space /[ \t\n\r]/ | comment end
  rule END /[ \t\n\r]*\.(\z|[ \t\n\r])/ end
  rule AND 'and' end
  rule variable_separator space* '=' end
end
